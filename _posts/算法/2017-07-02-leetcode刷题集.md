---
layout: post
title: leetcode刷题集
categories: 算法
description:leetcode
keywords: leetcode, 刷题
---
#leetcode
leetcode刷题地址：[https://leetcode.com/problemset/algorithms/](https://leetcode.com/problemset/algorithms/)
## 344. Reverse String
### 算法思路
倒序输出~~
### 编码实现
```java

    /**
     * 344. Reverse String
     * Example:
     * Given s = "hello", return "olleh".
     * @param s
     * @return
     */
    public String reverseString(String s) {
        if(s.length()<=1){
            return s;
        }
        StringBuffer sbf=new StringBuffer();
        for(int i=s.length()-1;i>=0;i--){
            sbf.append(s.charAt(i));
        }
        return sbf.toString();
    }
```
## 461. Hamming Distance
### 问题描述
The [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, calculate the Hamming distance.

Note:
0 ≤ x, y < 231.

Example:

Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.
### 算法思路
按位求异或，然后将结果转换为二进制，输出为1的个数。
### 编码实现
```java

 	/**
     * 461  汉明距离
     * @param x
     * @param y
     * @return
     */
    public int hammingDistance(int x, int y) {
        String result=Integer.toBinaryString(x^y);
        int diff=0;
        for(int i=0;i<result.length();i++){
            if(result.charAt(i)=='1'){
                diff++;
            }
        }
        return diff;
    }
```
## 617. Merge Two Binary Trees
### 问题描述
Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.

You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.


Example 1:
Input: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
Output: 
Merged tree:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7


Note: The merging process must start from the root nodes of both trees.
### 算法思路
用到递归的方法，用二叉树前序遍历的方法，依次求出值，最后返回根节点。
### 编码实现
```java

	public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if(t1==null&&t2==null){
            return null;
        }else if(t1==null&&t2!=null){
            return t2;
        }else if(t1!=null&&t2==null){
            return t1;
        }else{
            t1.val+=t2.val;
            t1.left=mergeTrees(t1.left,t2.left);
            t1.right=mergeTrees(t1.right,t2.right);
        }
        return t1;
    }
```